# Projetos de Sistemas Embarcados - EmbarcaTech 2025

Autor: **Guilherme Achilles de Oliveira e Aguiar**  
Curso: Resid√™ncia Tecnol√≥gica em Sistemas Embarcados  
Institui√ß√£o: EmbarcaTech - HBr  
Bras√≠lia, 09/05 de 2025

---

## üéØ Descri√ß√£o

Este projeto implementa uma **Galton Board digital** em um microcontrolador **Raspberry Pi Pico W**, simulando a distribui√ß√£o de uma vari√°vel binomial atrav√©s da queda de esferas, com controle anal√≥gico de tend√™ncia (via potenci√¥metro) e exibi√ß√£o gr√°fica em um display OLED.

A aplica√ß√£o envolve conceitos de:

- Filas circulares (`ball_queue`)
- Leitura anal√≥gica (`analogic_read`)
- Controle via bot√µes (`button`)
- Renderiza√ß√£o gr√°fica (`write_display`, `draw_table`, `draw_graphic`)
- Gera√ß√£o pseudoaleat√≥ria (`random_number`)
- Din√¢mica de movimento (`system_dinamic`, `ball`)

---

## üõ†Ô∏è Estrutura do Projeto

```bash
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.c                   # Loop principal do jogo
‚îÇ   ‚îú‚îÄ‚îÄ utils/                   # Componentes auxiliares
‚îÇ   ‚îú‚îÄ‚îÄ driver/                  # Drivers de hardware (ADC, Display, Bot√µes)
‚îÇ   ‚îú‚îÄ‚îÄ include/                 # Headers compartilhados
‚îÇ   ‚îî‚îÄ‚îÄ CMakeLists.txt           # Configura√ß√£o para build
‚îú‚îÄ‚îÄ build/                       # Arquivos gerados pela compila√ß√£o
‚îú‚îÄ‚îÄ README.md                    # Este arquivo
‚îî‚îÄ‚îÄ .vscode/                     # Configura√ß√µes do VSCode (opcional)

## üß© Pasta `utils/`
```

A pasta `utils/` cont√©m os **m√≥dulos auxiliares respons√°veis pela l√≥gica central e visual da simula√ß√£o da Galton Board**. Cada arquivo implementa uma parte espec√≠fica do comportamento do sistema:

- **`ball_queue.c`**: Gerencia a **fila de bolas** em queda, controlando sua ordem e movimenta√ß√£o na simula√ß√£o.
- **`ball.c`**: Define a **estrutura, estado e din√¢mica individual de cada bola**, incluindo colis√µes e movimenta√ß√£o baseada em tend√™ncia.
- **`draw_graphic.c`**: Respons√°vel pela **exibi√ß√£o gr√°fica estat√≠stica**, desenha o histograma das quedas.
- **`draw_table.c`**: Renderiza a **estrutura da √°rvore (Galton Board)** e elementos visuais como linhas e contadores no display.
- **`random_number.c`**: Gera os **√¢ngulos aleat√≥rios** de desvio das bolas ao colidir com pinos, simulando a aleatoriedade do sistema.
- **`system_dinamic.c`**: Gerencia a **din√¢mica geral do sistema**, integrando leitura anal√≥gica (tend√™ncia), atualiza√ß√£o de estado e movimento.

> Esses arquivos formam a espinha dorsal da l√≥gica da simula√ß√£o, separando responsabilidades e facilitando manuten√ß√£o e testes.


# ‚öôÔ∏è Din√¢mica das Bolas

O comportamento din√¢mico das bolas neste sistema √© modelado com base em conceitos da f√≠sica cl√°ssica, em particular o movimento com acelera√ß√£o (gravidade), colis√µes el√°sticas e vetores de velocidade.

## üé± Objeto `ball`

O objeto `ball` representa a bola do jogo e encapsula suas propriedades f√≠sicas, estado e comportamento din√¢mico ao longo do tempo. Ele √© representado por uma `struct` com os seguintes campos:

```c
typedef struct {
    float position_initial[2];     // Posi√ß√£o inicial da bola [x, y]
    float position_final[2];       // Posi√ß√£o final (atual) da bola [x, y]
    float vel_x_y[2];              // Velocidade da bola nos eixos x e y
    uint32_t time_ball;            // Tempo (em microssegundos) da √∫ltima atualiza√ß√£o
    float angle_impact;            // √Çngulo de impacto em graus
    float state;                   // Dire√ß√£o do movimento vertical (1 = descendo, -1 = subindo)
    float tendencie;              // Desvio horizontal causado por influ√™ncia externa (ex: controle ADC)
    int detect_colision;          // Flag que indica se houve colis√£o
} ball;
```

### üîÑ Fun√ß√µes associadas √† bola

* `create_ball(ball *b)`: Inicializa a bola na posi√ß√£o (64, 0) com velocidade vertical padr√£o.
* `calculate_pos(ball *b)`: Atualiza a posi√ß√£o da bola em fun√ß√£o do tempo decorrido, levando em conta gravidade e tend√™ncia horizontal.
* `draw_ball(ball *b)`: Desenha a bola na tela, com base em sua posi√ß√£o atual.
* `change_state(ball *b)`: Inverte o estado vertical da bola (de subida para descida e vice-versa).
* `return_tendencie(int adc_value)`: Retorna a tend√™ncia horizontal da bola com base na leitura de um ADC (usado para controle externo).


## üìê Equa√ß√µes Utilizadas

### 1. Atualiza√ß√£o de velocidade vertical (gravidade)

```c
float v_y = b->vel_x_y[1] = +b->vel_x_y[1] + 10 * delta;
```

**Equa√ß√µes:**

$$
v = \sqrt{v_x^2 + v_y^2} \cdot 0.4
$$

$$
v_x = v \cdot \sin(\theta) + \text{tend√™ncia}
$$

$$
v_y = v \cdot \cos(\theta)
$$


- $\( v \):$ velocidade total com amortecimento (fator 0.4)  
- $\( \theta \)$: √¢ngulo de impacto (em graus)  
- **Tend√™ncia**: valor externo (como do ADC) que causa leve desvio lateral



### ‚öôÔ∏è Comportamento f√≠sico

A posi√ß√£o da bola √© atualizada segundo a f√≥rmula da cinem√°tica b√°sica:

```
x(t) = x‚ÇÄ + v‚Çì * Œît 
y(t) = y‚ÇÄ + v·µß * Œît + ¬Ω * g * Œît¬≤
```

* Onde `g = 10 m/s¬≤` √© a acelera√ß√£o gravitacional simulada no jogo.
* A tend√™ncia (`tendencie`) afeta o eixo X, criando um leve desvio lateral nas colis√µes.



### 2. C√°lculo da velocidade total e decomposi√ß√£o em componentes x e y

```c
float speed = sqrtf(powf(b->vel_x_y[0], 2) + powf(v_y, 2)) * 0.4f;
float vel_x = b->vel_x_y[0] = speed * sinf(b->angle_impact * M_PI / 180) + b->tendencie;
b->vel_x_y[1] = speed * cosf(b->angle_impact * M_PI / 180);
```

**Equa√ß√µes:**

$$
v_y = v_{y_0} + g \cdot \Delta t
$$

- $v_y$: nova velocidade vertical  
- $v_{y_0}$: velocidade vertical anterior  
- $g = 10 \ \text{m/s}^2$: acelera√ß√£o gravitacional  
- $\Delta t$: tempo desde a √∫ltima atualiza√ß√£o


---

### 3. Invers√£o da velocidade na colis√£o com paredes

```c
b->vel_x_y[0] = -b->vel_x_y[0];
```

**Interpreta√ß√£o:**  
A colis√£o com as paredes laterais √© modelada como uma **colis√£o el√°stica**, onde a componente horizontal da velocidade inverte seu sinal.

---

### 4. Verifica√ß√£o para transi√ß√£o de estado (queda lenta)

```c
if (velocity_y < 1)
```

Quando a velocidade vertical atinge um valor muito baixo, a bola √© considerada ‚Äúparada‚Äù ou pronta para mudar de fase/estado. Isso simula o fim do movimento entre dois pontos de impacto.

---

## üß™ Considera√ß√µes F√≠sicas

- A gravidade √© aplicada de forma simplificada como uma acelera√ß√£o constante de `10 m/s¬≤`.
- O movimento da bola √© calculado por vetores 2D \((x, y)\), com separa√ß√£o clara entre suas componentes horizontais e verticais.
- A simula√ß√£o considera **pequenas colis√µes discretas com obst√°culos**, a partir de uma √°rvore de pontos.
- O fator de amortecimento `0.4` simula perda de energia ap√≥s impactos (como resist√™ncia do ar ou atrito).
- O sistema √© idealizado e discreto, ajustado ao tempo de execu√ß√£o e n√£o cont√≠nuo.

## üé≤ Randomiza√ß√£o de √Çngulos

### üéØ Objetivo da Randomiza√ß√£o

A randomiza√ß√£o de √¢ngulos √© crucial para simular o comportamento aleat√≥rio das bolas ao colidirem com obst√°culos na Galton Board, introduzindo imprevisibilidade no sistema.

### üî¢ Implementa√ß√£o da Fun√ß√£o `random_angle_degrees()`

```c
#include <stdlib.h>

float random_angle_degrees() {
    int angle = (rand() % 36) + 10; // Gera n√∫mero de 10 a 36
    if (rand() % 2 == 0) {
        return -angle;  // Negativo
    } else {
        return angle;   // Positivo
    }
}
```

### üìê Detalhamento da Gera√ß√£o de √Çngulos

#### 1. Intervalo de √Çngulos
- **Faixa**: 10¬∞ a 45¬∞
- **M√©todo**: `(rand() % 36) + 10`
  - `rand() % 36` gera n√∫meros de 0 a 35
  - `+ 10` desloca o intervalo para 10 a 45

#### 2. Sinal do √Çngulo
- 50% de chance de ser positivo
- 50% de chance de ser negativo
- Implementado por `rand() % 2 == 0`

### üß† Fun√ß√£o de Inicia√ß√£o de Seed

```c
void initiate_seed() {
    srand(2);  // Seed fixa para reprodutibilidade
}
```

### üîç Caracter√≠sticas da Randomiza√ß√£o

- **Reprodutibilidade**: Usa seed fixa para consist√™ncia entre execu√ß√µes
- **Distribui√ß√£o Uniforme**: 
  - √Çngulos entre -45¬∞ e -10¬∞
  - √Çngulos entre 10¬∞ e 45¬∞
- **Precis√£o**: Trabalha com n√∫meros inteiros, convertidos para float

### üí° Poss√≠veis Melhorias

- Usar geradores de n√∫meros aleat√≥rios mais sofisticados
- Implementar distribui√ß√£o de probabilidade mais complexa
- Adicionar variabilidade na amplitude dos √¢ngulos

### üìä Exemplo de Distribui√ß√£o

```
√Çngulos poss√≠veis:
- Positivos: 10¬∞, 11¬∞, 12¬∞, ..., 45¬∞
- Negativos: -10¬∞, -11¬∞, -12¬∞, ..., -45¬∞
- Total de 72 possibilidades
```

### üî¨ Impacto na Simula√ß√£o

A randomiza√ß√£o de √¢ngulos simula:
- Variabilidade natural do movimento
- Imprevisibilidade das colis√µes
- Comportamento pr√≥ximo a um sistema binomial

## üñ•Ô∏è Fun√ß√£o Main

### üîç Vis√£o Geral do Funcionamento

A fun√ß√£o `main()` √© o n√∫cleo do programa, respons√°vel por gerenciar o ciclo principal do sistema de simula√ß√£o de bolas.

### üöÄ Inicializa√ß√£o do Sistema

Quando o programa √© iniciado, a fun√ß√£o `main()` executa inicializa√ß√µes cruciais:

```c
stdio_init_all();
init_display();
init_buttons();
init_adc();
initiate_seed();
init_queue(&fila);
init_button_interrupts();
```

#### Detalhes das Inicializa√ß√µes

- **`stdio_init_all()`**: Inicializa comunica√ß√µes de entrada e sa√≠da
- **`init_display()`**: Prepara o display
- **`init_buttons()`**: Configura os bot√µes
- **`init_adc()`**: Inicializa leitura anal√≥gica
- **`initiate_seed()`**: Prepara gera√ß√£o de n√∫meros aleat√≥rios
- **`init_queue(&fila)`**: Inicializa a fila de bolas
- **`init_button_interrupts()`**: Configura interrup√ß√µes dos bot√µes

### üîÑ Loop Principal

O loop principal (`while(1)`) gerencia tr√™s fun√ß√µes principais:

#### 1. Gera√ß√£o de Bolas

```c
if (absolute_time_diff_us(ultimo_spawn, get_absolute_time()) > 90000)
{
    ball nova_bola;
    create_ball(&nova_bola);

    if (fila.count < MAX_BOLAS)
    {
        enqueue(&fila, &nova_bola);
        cont_balls++;
    }

    ultimo_spawn = get_absolute_time();
}
```

- Gera uma nova bola a cada 90 milissegundos
- Adiciona √† fila se n√£o exceder `MAX_BOLAS`
- Incrementa contador de bolas

#### 2. Modo Gr√°fico

```c
if (button_a_nivel)
{
    cancel_repeating_timer(&timer_contador);
    timer_reativado = false;

    while (button_a_nivel)
    {
        clear_display();
        draw_graphics((float)cont_balls);
        show_display();
        sleep_ms(100);
    }
}
```

- Ativa quando bot√£o A √© pressionado
- Cancela timer de atualiza√ß√£o normal
- Mostra gr√°fico com contagem de bolas
- Retorna ao modo normal ao soltar o bot√£o

#### 3. Atualiza√ß√£o de Display

```c
if (atualizar_display)
{
    show_display();
    atualizar_display = false;
}
```

- Monitora flag `atualizar_display`
- Mostra display quando flag √© verdadeira
- Reseta flag ap√≥s atualiza√ß√£o

### ‚öôÔ∏è Timer de Atualiza√ß√£o

- Timer configurado para `update_balls_timer_callback()` a cada 100ms
- Atualiza estado das bolas na fila
- Gerencia:
  - Colis√µes
  - C√°lculo de posi√ß√£o
  - Remo√ß√£o de bolas

### üîß Caracter√≠sticas T√©cnicas

- Usa `tight_loop_contents()` para otimiza√ß√£o de CPU
- Gerenciamento din√¢mico de timer
- Sistema de fila para m√∫ltiplas bolas
- Modo gr√°fico interativo

### üìã Fluxo de Execu√ß√£o

1. Inicializa√ß√£o completa
2. Entra em loop infinito
3. Gera bolas periodicamente
4. Verifica estado dos bot√µes
5. Atualiza display
6. Repete o processo

### ‚ö†Ô∏è Pontos de Aten√ß√£o

- Limite m√°ximo de bolas: `MAX_BOLAS`
- Gera√ß√£o de bolas controlada por tempo
- Modo gr√°fico mostra estat√≠sticas

### üí° Observa√ß√µes T√©cnicas

- Sistema de interrup√ß√£o para bot√µes
- Gerenciamento de mem√≥ria via fila circular
- Atualiza√ß√£o de estado baseada em timer

---

## üìà Resultados

A seguir, s√£o apresentados os **resultados obtidos ap√≥s a execu√ß√£o da simula√ß√£o** com diferentes valores de tend√™ncia (controle anal√≥gico), usando um total de 1000 bolas para cada cen√°rio.

### üîß Configura√ß√£o Experimental

* **N√∫mero de bolas**: 1000
* **Tempo entre lan√ßamentos**: 90ms
* **Tend√™ncia anal√≥gica (`tendencie`)**: Variada entre -5.0 (esquerda), 0.0 (neutra), +5.0 (direita)
* **Display**: OLED 128x64px, modo gr√°fico ativado com bot√£o
* **Distribui√ß√£o observada**: Histogramas exibidos em tempo real no display
* **Limite de pinos/sa√≠das na base da Galton Board**: 7 

---

### ‚öñÔ∏è 1. Tend√™ncia Neutra (`tendencie = 0.0`)

#### üìä Distribui√ß√£o Esperada:



Distribui√ß√£o **sim√©trica**, aproximando uma **binomial equilibrada**.


<p align ="center"><img src="https://github.com/EmbarcaTech-2025/lab01_galton_board-GuilhermeAchilles/blob/main/assets/i_resultado_1.PNG?raw=true" width="400" alt="Imagem da BitDogLab"></p>



#### üìä Distribui√ß√£o Observada:


> A distribui√ß√£o segue o comportamento esperado de uma curva normal discreta centrada, com maior ac√∫mulo no meio.


<p align ="center"><img src="https://github.com/GuilhermeAchilles/Guilherme_Achilles_embarcatech_HBr_2025/blob/main/Projetos/galton_board_u1/assets/i_resultado_1.JPG?raw=true" width="400" alt="Imagem da BitDogLab"></p>

---

### ‚¨ÖÔ∏è 2. Tend√™ncia √† Esquerda (`tendencie = -5.0`)

<p align ="center"><img src="https://github.com/GuilhermeAchilles/Guilherme_Achilles_embarcatech_HBr_2025/blob/main/Projetos/galton_board_u1/assets/i_resultado_3.PNG?raw=true" width="400" alt="Imagem da BitDogLab"></p>

#### üìä Distribui√ß√£o Esperada:

Deslocamento da curva para a **esquerda**, com maior ac√∫mulo nas posi√ß√µes iniciais.


#### üìä Distribui√ß√£o Observada:

<p align ="center"><img src="https://github.com/GuilhermeAchilles/Guilherme_Achilles_embarcatech_HBr_2025/blob/main/Projetos/galton_board_u1/assets/resultado_3.PNG?raw=true" width="400" alt="Imagem da BitDogLab"></p>

> O gr√°fico mostra claro **vi√©s √† esquerda**, indicando que o controle anal√≥gico influencia efetivamente o caminho das bolas.

---

### ‚û°Ô∏è 3. Tend√™ncia √† Direita (`tendencie = +5.0`)

<p align ="center"><img src="https://github.com/GuilhermeAchilles/Guilherme_Achilles_embarcatech_HBr_2025/blob/main/Projetos/galton_board_u1/assets/i_resultado_2.PNG?raw=true" width="400" alt="Imagem da BitDogLab"></p>

#### üìä Distribui√ß√£o Esperada:

Deslocamento da curva para a **direita**, com maior ac√∫mulo nas posi√ß√µes finais.

#### üìä Distribui√ß√£o Observada:

<p align ="center"><img src="https://github.com/GuilhermeAchilles/Guilherme_Achilles_embarcatech_HBr_2025/blob/main/Projetos/galton_board_u1/assets/resultado_2.PNG?raw=true" width="400" alt="Imagem da BitDogLab"></p>

> A curva desloca-se para a direita, confirmando a resposta din√¢mica ao input anal√≥gico.

---

## üìå An√°lise Geral

* A simula√ß√£o responde corretamente √†s varia√ß√µes de entrada anal√≥gica.
* O uso de f√≠sica simplificada com randomiza√ß√£o oferece **realismo suficiente** para observar o comportamento de uma distribui√ß√£o binomial influenciada.
* O histograma exibido em tempo real permite **interpreta√ß√£o visual clara** dos resultados.

